useLibrary( 'threads' );
importPackage( arkham.project );
importClass( javax.xml.parsers.DocumentBuilderFactory);
importClass( javax.xml.parsers.DocumentBuilder);
importClass( org.w3c.dom.Document);
importClass( org.w3c.dom.NodeList);
importClass( org.w3c.dom.Node);
importClass( org.w3c.dom.Element);
importClass( java.io.File);

Thread.busyWindow( main, 'Updating Cards...', true );

/*
Reads the setEons.xml file in same directory as this Strange Eons project and
produces a .eon file in the 'new' folder for each card.
*/
function main( progress, target ) {
	// First delete previous cards
	var delCards = project.findChild('Decks/new').iterator();
	while (delCards.hasNext()) 
		delCards.next().deleteFile();
		
	var fXmlFile = new File('setEons.xml');
	Console.err.println(fXmlFile);
	var dbFactory = DocumentBuilderFactory.newInstance();
	var dBuilder = dbFactory.newDocumentBuilder();
	var doc = dBuilder.parse(fXmlFile);
	doc.getDocumentElement().normalize();
	//Console.err.println("Root element :" + doc.getDocumentElement().getNodeName());
	var cardSet = doc.getDocumentElement().getAttribute("name");
	var nList = doc.getElementsByTagName("card");
	//Console.err.println("--------------------------------------");
	// Loop over cards in set
	for (let i = 0; i < nList.getLength(); i++) {
		// Create a dictionary called card that contains all the card info in the xml file
		var card = {};
		card['Set'] = cardSet;
		var nNode = nList.item(i);
		//Console.err.println("\nCurrent Element :" + nNode.getNodeName());
		if (nNode.getNodeType() == Node.ELEMENT_NODE) {
			//Console.err.println("\n\tCard id : " + nNode.getAttribute("id"));
			card['octgn'] = nNode.getAttribute("id");
			//Console.err.println("\n\tName : " + nNode.getAttribute("name"));
			card['Name'] = nNode.getAttribute("name");
			var propList = nNode.getElementsByTagName("property");
			for (let j = 0; j < propList.getLength(); j++) {
				var nProp = propList.item(j);
				if (!nProp.getParentNode().isSameNode(nNode)) continue;
				if (nProp && nProp.getNodeType() == Node.ELEMENT_NODE) {
					//Console.err.println("\n\t" + nProp.getAttribute("name")+': '+nProp.getAttribute("value"));
					card[nProp.getAttribute("name")] = nProp.getAttribute("value");
				}
			}
			var altList = nNode.getElementsByTagName("alternate");
			for (let k = 0; k < altList.getLength(); k++) {
				var nAlternate = altList.item(k);
				if (nAlternate && nAlternate.getNodeType() == Node.ELEMENT_NODE) {
					//Console.err.println("\n\t\tSide B: " + nAlternate.getAttribute("name"));
					card['BName'] = nAlternate.getAttribute("name");
					var altPropList = nAlternate.getElementsByTagName("property");
					for (let l = 0; l < altPropList.getLength(); l++) {
						var nAltProp = altPropList.item(l);
						if (nAltProp && nAltProp.getNodeType() == Node.ELEMENT_NODE) {
							//Console.err.println("\n\t\t" + nAltProp.getAttribute("name")+': '+nAltProp.getAttribute("value"));
							card['B'+nAltProp.getAttribute("name")] = nAltProp.getAttribute("value");
						}
					}
				}
			}
		}

		if (card['Type'] == 'Side Quest') {
			if (card['Encounter Set']) {
				card['Type'] = 'Encounter Side Quest';
			}
			else {
				card['Type'] = 'Player Side Quest';
			}
		}
		if (card['BType'] == 'Side Quest') {
			if (card['Encounter Set']) {
				card['BType'] = 'Encounter Side Quest';
			}
			else {
				card['BType'] = 'Player Side Quest';
			}
		}

		if (card['Type'] == 'Quest' && card['BQuest Points']) {
			card['Quest Points'] = card['BQuest Points'];
		}

		if (['Ally', 'Attachment', 'Event', 'Player Side Quest'].indexOf(card['Type'] + '') > -1 && card['Quantity'] == 3) {
			card['Quantity'] = 1;
		}

		for (let j = 0; j < card['Quantity']; j++) {
			var sides = ['front'];
			if (['Quest', 'Rules'].indexOf(card['Type'] + '') == -1 && card['BName']) {
				sides.push('back');
			}
			for (let s = 0; s < sides.length; s++) {
				var side = sides[s];
				var card_name, card_type, translate;
				if (side == 'front') {
					card_name = card['Name'];
					card_name = card['Type'];
					translate= [
						// Convert from member name in xml file to member name in eon file
						// [eon,xml]
						['CollectionNumber', 'Card Number'],
						['Name', 'Name'],
						['Unique', 'Unique'],
						['Template', 'Sphere'],
						['Trait', 'Traits'],
						// Keywords
						['ResourceCost', 'Cost'],
						['ThreatCost', 'Cost'],
						['Stage', 'Cost'],
						['Engagement', 'Engagement Cost'],
						['Threat', 'Threat'],
						['Willpower', 'Willpower'],
						['Attack', 'Attack'],
						['Defense', 'Defense'],
						['HitPoints', 'Health'],
						['Progress', 'Quest Points'],
						['Victory', 'Victory Points'],
						['OptionRight', 'Victory Points'],
						['Rules', 'Text'],
						['Shadow', 'Shadow'],
						['Flavour', 'Flavour'],
						['Story', 'Flavour'],
						['Artist', 'Artist'],
						['NameBack', 'BName'],
						['RulesBack', 'BText'],
						['FlavourBack', 'BFlavour'],
						['StoryBack', 'BFlavour'],
						['ArtistBack', 'BArtist'],
						['Adventure', 'Adventure']
					];
				}
				else {
					card_name = card['BName'];
					card_name = card['BType'];
					translate= [
						// Convert from member name in xml file to member name in eon file
						// [eon,xml]
						['CollectionNumber', 'Card Number'],
						['Name', 'BName'],
						['Unique', 'BUnique'],
						['Template', 'BSphere'],
						['Trait', 'BTraits'],
						// Keywords
						['ResourceCost', 'BCost'],
						['ThreatCost', 'BCost'],
						['Stage', 'BCost'],
						['Engagement', 'BEngagement Cost'],
						['Threat', 'BThreat'],
						['Willpower', 'BWillpower'],
						['Attack', 'BAttack'],
						['Defense', 'BDefense'],
						['HitPoints', 'BHealth'],
						['Progress', 'BQuest Points'],
						['Victory', 'BVictory Points'],
						['OptionRight', 'BVictory Points'],
						['Rules', 'BText'],
						['Shadow', 'BShadow'],
						['Flavour', 'BFlavour'],
						['Story', 'Flavour'],
						['Artist', 'Artist']
					];
				}

				// Create a new .eon file, using the appropriate template in the template folder
				progress.status = card_name;
				var newCard = ResourceKit.getGameComponentFromFile(getProjectMember('Decks/template/' + card_type + '.eon').file, false);
				var s = newCard.settings;

				// change the details in the template card
				for (let k = 0; k < translate.length; k++) {
					var nEon = translate[k][0];
					s.set(nEon, '');
					var nXml = translate[k][1];
					var vXml = card[nXml];
					if (!vXml) {
						continue;
					}
					if (vXml == '-') {
						vXml = 'minus';
					}
					if (vXml == '\u2030') {
						vXml = '1';
					}
					if (nXml == 'Victory Points') {
						vXml = 'VICTORY ' + vXml;
					}
					if (nXml == 'Text') {
						if (card['Keywords']) {
							if (card['Type'] == 'Rules') {
								vXml = '\n<se>' + card['Keywords'] + '</se>\n\n' + vXml;
							}
							else {
								vXml = card['Keywords'] + '\n\n' + vXml;
							}
						}
						if (['Hero', 'Ally', 'Attachment', 'Event', 'Enemy', 'Location', 'Treachery', 'Objective', 'Objective Ally'
							].indexOf(card['Type'] + '') > -1 && !card['Traits']) {
							vXml = '\n' + vXml;
						}
					}
					vXml = markUp(vXml); // make stuff like 'Response:' appear bold
					s.set(nEon, vXml);
				}

				if (card['Type'] == 'Quest') {
					s.set('NameShare', 0);
				}
				if (card['Artwork']) {
					s.set('Portrait-external-path', 'project:imagesRaw/' + card['Artwork']);
				}
				if (card['BArtwork']) {
					s.set('PortraitBack-external-path', 'project:imagesRaw/' + card['BArtwork']);
					s.set('PortraitShare', 0);
				}
				s.set('Collection', 'CustomIcon');
				s.set('Collection-external-path', ('project:imagesIcons/' + card['Set'] + '.png').replace(/ /g, '-'));
				if (card['Encounter Set']) {
					s.set('EncounterSet', 'CustomIcon');
					s.set('EncounterSet-external-path', ('project:imagesIcons/' + card['Encounter Set'] + '.png').replace(/ /g, '-'));
				}
				if (card['Additional Encounter Sets']) {
					var encounterSets = card['Additional Encounter Sets'].split(',');
					for (let k = 0; k < encounterSets.length; k++) {
						s.set('EncounterSet' + (k + 1) + '-external-path',
							('project:imagesIcons/' + encounterSets[k].trim() + '.png').replace(/ /g, '-'));
					}
				}
				if (card['Encounter Set Number']) {
					s.set('EncounterSetNumber', parseInt(card['Encounter Set Number']) + j);
				}
				if (card['Encounter Set Total']) {
					s.set('EncounterSetTotal', card['Encounter Set Total']);
				}
				if (card['Removed for Easy Mode'] && j >= parseInt(card['Quantity']) - parseInt(card['Removed for Easy Mode'])) {
					s.set('Template', 'Gold');
				}
				s.set('CollectionInfo', ' ');
				s.set('Copyright', '©Middle-earth Ent. ©FFG ©ALeP');

				// save new .eon file in the 'new' folder
				var copy;
				if (['Ally', 'Attachment', 'Event', 'Player Side Quest'].indexOf(card['Type'] + '') > -1 && card['Quantity'] == 1) {
					copy = 'p';
				}
				else {
					copy = j + 1;
				}
				var fname = (Array(4 - (card['Card Number'] + '').length).join('0') + card['Card Number'] + '-' + copy + '-' +
					card['Name'] + Array(50).join('-')).substring(0, 50) + card['octgn'] + '.eon';
				progress.status = fname;
				ResourceKit.writeGameComponentToFile(new File(getProjectMember('Decks/new/').file, fname), newCard);
			}
		}
	}
	return;
}

function markUp(vXml) { 
	vXml = (vXml + '').replace(/\bQuest Resolution( \([^\)]+\))?:/g, '<b>Quest Resolution</b>$1:');
	vXml = vXml.replace(/\b(Resource |Planning |Quest |Travel |Encounter |Combat |Refresh )?Action:/g, '<b>$1Action</b>:');
	vXml = vXml.replace(/\b(When Revealed|Setup|Forced|Response|Travel|Shadow):/g, '<b>$1</b>:');
	vXml = vXml.replace(/\bCondition\b/g, '<b><i>Condition</i></b>');
	vXml = vXml.replace(/\$|\[Threat\]/g, '<thr>');
	vXml = vXml.replace(/\u00db|\[Attack\]/g, '<att>');	
	vXml = vXml.replace(/\u00da|\[Defense\]/g, '<def>');	
	vXml = vXml.replace(/\u00d2|\[Willpower\]/g, '<wil>');	
	vXml = vXml.replace(/\u00cc|\[Leadership\]/g, '<lea>');	
	vXml = vXml.replace(/\u00ce|\[Lore\]/g, '<lor>');	
	vXml = vXml.replace(/\u00ca|\[Spirit\]/g, '<spi>');	
	vXml = vXml.replace(/\u00cf|\[Tactics\]/g, '<tac>');	
	vXml = vXml.replace(/\u2030|\[Unique\]/g, '<uni>');
	vXml = vXml.replace(/\^/g, '<b><i>');
	vXml = vXml.replace(/\*/g, '</i></b>');
	vXml = vXml.replace(/~/g, '<b>');
	vXml = vXml.replace(/%/g, '</b>');
	vXml = vXml.replace(/\n\n/g, '\n<vs>\n');
	return vXml;
}

/**
 * getProjectMember( path )
 *   path : a path relative to the project folder
 * Given a /-separated path in the project, returns a Member for
 * the file represented by that path.
 */
function getProjectMember( path ) {
	var member = project.findChild( path );
	if( member == null ) {
		throw new Error( 'missing required project file: ' + path );
	}
	return member;
}